<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ATN Claim</title>
  <style>
  /* Keep your existing dark palette */
  :root{
    --fg:#f1f5f9;       /* primary text (light) */
    --muted:#94a3b8;    /* secondary text */
    --border:#334155;   /* dark border */
    --card:#0f172a;     /* card background */
    --bg:#1e293b;       /* page background */
    --brand:#3b82f6;    /* brand blue */
  }

  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Roboto,Arial;
    background:var(--bg);
    color:var(--fg);
    font-size:16px; line-height:1.45;
  }
  .wrap{max-width:1200px;margin:32px auto;padding:0 24px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:18px}

  h1{margin:0 0 14px 0;font-size:24px;display:flex;align-items:center;gap:10px}

  .row{display:flex;gap:10px;flex-wrap:wrap;margin:12px 0}

  /* Inputs/selects with dark background & light text */
  input,select{
    padding:12px 14px;border-radius:12px;
    border:1px solid var(--border);
    background:#0b1220; color:var(--fg);
    font-size:16px;
  }
  input::placeholder{color:#8aa0b5}

  /* Buttons */
  button{
    padding:12px 14px;border-radius:12px;
    background:var(--brand);color:#fff;border:none;cursor:pointer;font-size:16px
  }
  button:hover:not(:disabled){filter:brightness(1.05)}
  button:active:not(:disabled){transform:translateY(1px)}
  button:disabled{opacity:.5;cursor:not-allowed}

  .muted{color:#cbd5e1;font-size:13px}

  /* Table (dark) */
  table{width:100%;border-collapse:collapse;margin-top:14px;color:var(--fg)}
  th,td{border-top:1px solid var(--border);padding:12px 10px;text-align:left;font-variant-numeric:tabular-nums}
  th{background:#0b1220;color:#e2e8f0}

  /* KPIs */
  .kpi{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:14px;margin-top:14px}
  .kpi .card{padding:16px}
  .kpi .v{font-size:22px;font-weight:700;color:#e6edf3}

  /* Chart canvas */
  canvas{
    width:100%;height:360px;
    border:1px solid rgba(148,163,184,.15);
    border-radius:10px;
    background:#0b1220;
  }

  .mono{font-family:ui-monospace,Consolas,monospace}
  .readonly{background:#0b1220}
  pre{background:#0b1220;color:#e5e7eb;border-radius:12px;padding:12px;overflow:auto}

  .dot{display:inline-block;width:8px;height:8px;border-radius:50%;margin:0 6px}
  .dot.online{background:#16a34a}
  .dot.offline{background:#9ca3af}

  @media(max-width:640px){
    .wrap{padding:0 16px}
    .kpi{grid-template-columns:1fr}
    h1{font-size:20px}
  }
</style>

  <!-- Ethers v6 (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1 style="display:flex;align-items:center;gap:10px;margin:0">
  <img src="/claim/images/logo-32.png?v=2"
       alt="ATN Logo"
       style="width:28px;height:28px;border-radius:6px;object-fit:contain">
  ATN Claim
</h1>

      <div class="row">
        <input id="wallet" placeholder="0x... BSC wallet" style="flex:1" />
        <select id="days">
         <option value="1" selected>1 day</option>
         <option value="7">7 days</option>
         <option value="14">14 days</option>
         <option value="30">30 days</option>
        </select>
        <button id="btnView">View</button>
      </div>

      <div class="row">
        <button id="btnCheck">Check claimable balance</button>
        <button id="btnReq">Submit payout request (off-chain)</button>
        <button id="btnClaim" disabled title="Will enable when Merkle proof/contract are available">Claim on-chain</button>
      </div>

      <div class="muted">API: <span id="api">https://api.atncrypto.com</span>
        <span id="devBox" class="muted" style="margin-left:8px"></span>
      </div>

      <div class="kpi">
        <div class="card"><div class="muted">Total GB</div><div id="kpiGB" class="v">0</div></div>
        <div class="card"><div class="muted">Estimated ATN</div><div id="kpiATN" class="v">0</div></div>
        <div class="card"><div class="muted">Days with data</div><div id="kpiDays" class="v">0</div></div>
      </div>

      <div style="margin-top:14px" class="card">
        <canvas id="chart" width="800" height="260"></canvas>
      </div>

      <div class="card" style="margin-top:14px">
        <table>
          <thead><tr><th>Date (UTC)</th><th>GB</th><th>ATN (estimated)</th></tr></thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>

      <div class="card" style="margin-top:14px">
        <div class="muted">Log</div>
        <pre id="log" class="mono"></pre>
      </div>
    </div>
  </div>

<script>
(function(){
  // ====== CONFIG ======
  const API = 'https://api.atncrypto.com'; // change if your backend differs
  const AIRDROP_CONTRACT = '0xc956969fc7dad2B1654Ad98f183A3fDFCE325341'; // your airdrop contract
  document.getElementById('api').textContent = API;

  // Minimal ABI
  const AIRDROP_ABI = [
    {"inputs":[{"internalType":"uint256","name":"day","type":"uint256"},{"internalType":"uint256","name":"index","type":"uint256"},{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"amountWei","type":"uint256"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"claim","outputs":[],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[{"internalType":"uint256","name":"day","type":"uint256"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"isClaimed","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
    {"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"roots","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"}
  ];

  // ====== Helpers ======
  const $ = sel => document.querySelector(sel);
  const log = (msg) => { const el = $('#log'); el.textContent = (el.textContent ? el.textContent + "\n" : "") + msg; };
  const clearLog = () => $('#log').textContent = '';
  const isWallet = v => /^0x[a-fA-F0-9]{40}$/.test((v||'').trim());
  async function fetchJSON(url, opts){
    const res = await fetch(url, opts);
    const ct = res.headers.get('content-type') || '';
    const txt = await res.text();
    if (!res.ok) throw new Error(`HTTP ${res.status}: ${txt.slice(0,180)}`);
    if (!ct.includes('application/json')) throw new Error(`Not JSON: ${txt.slice(0,180)}`);
    return JSON.parse(txt);
  }
  const fmt = (n, digits=6) => Number(n||0).toLocaleString('en-US',{maximumFractionDigits:digits});
  function z2(n){return String(n).padStart(2,'0');}
  function yesterdayStrUTC(){
    const t=new Date(); t.setUTCDate(t.getUTCDate()-1);
    return `${t.getUTCFullYear()}-${z2(t.getUTCMonth()+1)}-${z2(t.getUTCDate())}`;
  }

  // ====== URL params ======
  const qs = new URLSearchParams(location.search);
  const urlClaimDay = qs.get('claim_day') || '';
  const walletEl = $('#wallet');
  const urlWallet = qs.get('wallet') || '';
  const urlDevice = qs.get('device') || '';
  const devBox = $('#devBox');
  if (urlWallet) { walletEl.value = urlWallet; walletEl.readOnly = true; walletEl.classList.add('readonly'); }

  // ====== Device helpers ======
  let deviceParam = urlDevice;
  async function ensureDeviceId(wallet){
    if (deviceParam) return deviceParam;
    if (!isWallet(wallet)) return '';
    try{
      const j = await fetchJSON(`${API}/device/binding?wallet=${encodeURIComponent(wallet)}`);
      if (j && j.device_id){
        deviceParam = j.device_id;
        updateDeviceBadge(wallet, deviceParam, false);
      }
    }catch(e){ log('Unable to obtain device_id from server: ' + e.message); }
    return deviceParam;
  }
  function updateDeviceBadge(wallet, device, online){
    const dot = `<span class="dot ${online===true?'online':(online===false?'offline':'')}"></span>`;
    devBox.innerHTML = `Device: ${device||'-'} ${dot}${online===true?'Online':(online===false?'Offline':'')}`;
  }
  let onlineTimer=null;
  async function pingOnline(){
    const w = walletEl.value.trim();
    if (!isWallet(w)) return;
    const d = await ensureDeviceId(w);
    if (!d) return;
    try{
      const r = await fetchJSON(`${API}/device/online?wallet=${encodeURIComponent(w)}&device=${encodeURIComponent(d)}`);
      updateDeviceBadge(w, d, !!r.online);
    }catch{ updateDeviceBadge(w, d, false); }
  }

  // ====== History ======
  async function fetchHistory(wallet, days){
    return fetchJSON(`${API}/stats/history?wallet=${encodeURIComponent(wallet)}&days=${days}`);
  }
function drawChart(canvas, points){
  // Crisp rendering on high-DPI (retina)
  const dpr = window.devicePixelRatio || 1;
  const cssW = canvas.clientWidth || canvas.width;
  const cssH = canvas.clientHeight || canvas.height;
  canvas.width  = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels

  const W = cssW, H = cssH;

  // Padding & style
  const L=44, R=14, T=16, B=34;
  const w=W-L-R, h=H-T-B;

  // Plot background
  ctx.clearRect(0,0,W,H);
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(148,163,184,.15)'; // subtle grid
  ctx.fillStyle   = 'rgba(15,23,42,.02)';
  ctx.fillRect(L,T,w,h);
  ctx.strokeRect(L,T,w,h);

  if (!points || points.length === 0) return;

  // Scale
  const ys = points.map(p => +p.gb || 0);
  const yMaxRaw = Math.max(...ys, 1);
  const mag = Math.pow(10, Math.floor(Math.log10(yMaxRaw)));
  const yMax = Math.ceil(yMaxRaw / (0.5*mag)) * (0.5*mag);

  const xStep = w / Math.max(1, points.length - 1);
  const xAt = i => L + i * xStep;
  const yAt = v => T + h - (v / yMax) * h;

  // Horizontal grid + Y labels
  ctx.fillStyle = 'rgba(148,163,184,.7)';
  ctx.font = '13px system-ui, sans-serif';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  const ticks = 4;
  for (let i=0;i<=ticks;i++){
    const yy = T + h - (i/ticks)*h;
    ctx.beginPath(); ctx.moveTo(L,yy); ctx.lineTo(W-R,yy); ctx.stroke();
    const label = (yMax*i/ticks).toLocaleString('en-US', {maximumFractionDigits:2});
    ctx.fillText(label, 6, yy);
  }

  // Line gradient & area fill
  const grad = ctx.createLinearGradient(L, T, L, T+h);
  grad.addColorStop(0, '#3b82f6');
  grad.addColorStop(1, '#2563eb');

  const areaGrad = ctx.createLinearGradient(0, T, 0, T+h);
  areaGrad.addColorStop(0, 'rgba(59,130,246,.32)');
  areaGrad.addColorStop(1, 'rgba(59,130,246,0)');

  // Area path
  ctx.beginPath();
  points.forEach((p,i) => {
    const x = xAt(i);
    const y = yAt(+p.gb||0);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.lineTo(L + (points.length-1)*xStep, T+h);
  ctx.lineTo(L, T+h);
  ctx.closePath();
  ctx.fillStyle = areaGrad;
  ctx.fill();

  // Line
  ctx.beginPath();
  points.forEach((p,i) => {
    const x = xAt(i);
    const y = yAt(+p.gb||0);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.lineWidth = 2.5;
  ctx.lineJoin = 'round';
  ctx.lineCap  = 'round';
  ctx.strokeStyle = grad;
  ctx.stroke();

  // Markers with glow
  points.forEach((p,i)=>{
    const x=xAt(i), y=yAt(+p.gb||0);
    ctx.save();
    ctx.shadowColor = 'rgba(59,130,246,.45)';
    ctx.shadowBlur = 6;
    ctx.fillStyle = '#3b82f6';
    ctx.beginPath(); ctx.arc(x,y,3.2,0,Math.PI*2); ctx.fill();
    ctx.restore();
  });

  // X labels (sparse)
  ctx.fillStyle = 'rgba(148,163,184,.9)';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'alphabetic';
  const step = Math.ceil(points.length/5);
  points.forEach((p,i)=>{
    if (i%step!==0 && i!==points.length-1) return;
    const x=xAt(i);
    ctx.fillText(p.day, x, H-8);
  });

  // return geometry for tooltip
  return {
    xAt, yAt, yMax, rect:{L,R,T,B,w,h,W,H}
  };
}


  // ====== View button ======
  async function viewHistory(){
    clearLog();
    const wallet = walletEl.value.trim();
    const days = Number($('#days').value);
    if (!isWallet(wallet)) { alert('Enter a valid BSC wallet (0x + 40 hex).'); return; }
    $('#btnView').disabled = true;
    try{
      const data = await fetchHistory(wallet, days);
      const list = Array.isArray(data.daily) ? data.daily : [];
      const totalGB = list.reduce((s,x)=>s+Number(x.gb||0),0);
      const totalATN = list.reduce((s,x)=>s+Number(x.est_atn||0),0);
      $('#kpiGB').textContent = fmt(totalGB,6);
      $('#kpiATN').textContent = fmt(totalATN,6);
      $('#kpiDays').textContent = list.length;
      const tbody = $('#tbody'); tbody.innerHTML='';
      list.forEach(row=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${row.day}</td><td>${fmt(row.gb,6)}</td><td>${fmt(row.est_atn,6)}</td>`;
        tbody.appendChild(tr);
      });
      const points = list.map(r=>({day:r.day, gb:r.gb, ts: Date.parse(r.day+'T00:00:00Z')||0}));

const canvas = $('#chart');
let geom = drawChart(canvas, points);

// Canvas hover tooltip
(function attachTooltip(){
  const state = { idx: -1 };
  canvas.onmousemove = (e)=>{
    if (!points.length || !geom) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left);
    const i = Math.round((x - geom.rect.L) / (geom.rect.w / Math.max(1, points.length-1)));
    const idx = Math.min(points.length-1, Math.max(0, i));
    if (idx === state.idx) return;
    state.idx = idx;

    // redraw + overlay tooltip
    geom = drawChart(canvas, points);
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    ctx.setTransform(dpr,0,0,dpr,0,0);

    const px = geom.xAt(idx);
    const py = geom.yAt(+points[idx].gb||0);

    // crosshair
    ctx.strokeStyle = 'rgba(148,163,184,.35)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(px, geom.rect.T); ctx.lineTo(px, geom.rect.T+geom.rect.h); ctx.stroke();

    // popup
    const pad=8;
    const text1 = points[idx].day;
    const text2 = `${Number(points[idx].gb||0).toLocaleString('en-US',{maximumFractionDigits:6})} GB`;
    ctx.font = '12px system-ui, sans-serif';
    const w = Math.max(ctx.measureText(text1).width, ctx.measureText(text2).width) + pad*2;
    const h = 34;
    let bx = px + 10, by = py - h - 10;
    if (bx + w > geom.rect.W - geom.rect.R) bx = px - w - 10;
    if (by < geom.rect.T) by = py + 10;

    ctx.fillStyle = 'rgba(2,6,23,.9)';
    ctx.strokeStyle = 'rgba(59,130,246,.6)';
    ctx.lineWidth = 1;
    if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(bx, by, w, h, 8); ctx.fill(); ctx.stroke(); }
    else { ctx.fillRect(bx, by, w, h); ctx.strokeRect(bx, by, w, h); }

    ctx.fillStyle = '#e2e8f0';
    ctx.textAlign='left'; ctx.textBaseline='top';
    ctx.fillText(text1, bx+pad, by+6);
    ctx.fillStyle = '#93c5fd';
    ctx.fillText(text2, bx+pad, by+18);
  };

  canvas.onmouseleave = ()=>{
    state.idx = -1;
    geom = drawChart(canvas, points);
  };

  window.addEventListener('resize', ()=>{ geom = drawChart(canvas, points); });
})();

log('History loaded.');

      await refreshClaimEligibility();
    }catch(e){ alert('Failed to load data: ' + e.message); log('History error: ' + e.message); console.error(e);
    }finally{ $('#btnView').disabled = false; }
  }

  // ====== Off-chain balance ======
  async function checkBalance(){
    clearLog();
    const wallet = walletEl.value.trim();
    if (!isWallet(wallet)) { alert('Invalid wallet.'); return; }
    try{
      const r = await fetchJSON(`${API}/payout/balance?wallet=${encodeURIComponent(wallet)}`);
      log(JSON.stringify(r, null, 2));
      if (+r.available_atn >= +r.min) log('✅ Threshold met — you can create a payout request.'); else log('ℹ️ Not enough yet for payout.');
    }catch(e){ log('Balance error: ' + e.message); }
  }

  // ====== Create off-chain request ======
  async function requestPayout(){
    clearLog();
    const wallet = walletEl.value.trim();
    if (!isWallet(wallet)) { alert('Invalid wallet.'); return; }
    const device = await ensureDeviceId(wallet);
    if (!device){ alert('Missing device_id. Open this page from the Extension after registering your device.'); log('Missing device_id — cannot create payout request.'); return; }
    try{
      const r = await fetchJSON(`${API}/payout/request`, {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ wallet, device_id: device })
      });
      log(JSON.stringify(r, null, 2));
      if (r.ok) log('✅ Payout request recorded.');
    }catch(e){ log('Payout error: ' + e.message); }
  }

  // ====== Airdrop APIs ======
  async function getAirdropStatus(wallet, dayStr){
    return fetchJSON(`${API}/airdrop/status?wallet=${encodeURIComponent(wallet)}&day=${encodeURIComponent(dayStr)}`);
  }
  async function getAirdropProof(wallet, dayStr){
    return fetchJSON(`${API}/airdrop/proof?wallet=${encodeURIComponent(wallet)}&day=${encodeURIComponent(dayStr)}`);
  }

  async function refreshClaimEligibility(){
    const btn = $('#btnClaim');
    btn.disabled = true;
    btn.title = 'Will enable when Merkle proof/contract are available';
    const wallet = walletEl.value.trim();
    if (!isWallet(wallet)) return;
    const dayStr = urlClaimDay || yesterdayStrUTC();
    try{
      const st = await getAirdropStatus(wallet, dayStr);
      if (!st.hasEntry){ btn.title = `Wallet not in airdrop for ${dayStr}`; return; }
      if (st.claimed){ btn.title = `Already claimed for ${dayStr}`; return; }
      btn.disabled = false;
      btn.title = `Claim ${st.amountWei} wei for ${dayStr}`;
    }catch(e){
      log('Status error: ' + e.message);
    }
  }

  // ====== MetaMask / BSC signer ======
  async function getSignerBSC(){
    if (!window.ethereum) throw new Error('No wallet detected (MetaMask).');
    const provider = new ethers.BrowserProvider(window.ethereum);
    let net = await provider.getNetwork();
    if (net.chainId !== 56n){
      try{
        await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: '0x38' }] });
      }catch (err){
        if (err && (err.code === 4902 || err.code === -32603)){
          await window.ethereum.request({
            method:'wallet_addEthereumChain',
            params:[{
              chainId:'0x38',
              chainName:'Binance Smart Chain',
              nativeCurrency:{ name:'BNB', symbol:'BNB', decimals:18 },
              rpcUrls:['https://bsc-dataseed.binance.org'],
              blockExplorerUrls:['https://bscscan.com']
            }]
          });
        }else{
          throw err;
        }
      }
    }
    return provider.getSigner();
  }

  // ====== Claim on-chain ======
  async function claimOnChain(dayStrOverride){
    clearLog();
    try{
      const wallet = walletEl.value.trim();
      if (!isWallet(wallet)) throw new Error('Invalid wallet.');
      const dayStr = dayStrOverride || urlClaimDay || yesterdayStrUTC();

      // 1) fetch proof from backend
      const proof = await getAirdropProof(wallet, dayStr);
      // proof: { day:"20250831", index, account, amountWei, proof:[...] }

      // 2) signer + contract
      const signer = await getSignerBSC();
      const c = new ethers.Contract(AIRDROP_CONTRACT, AIRDROP_ABI, signer);

      // 3) root must exist on-chain
      const root = await c.roots(BigInt(proof.day));
      if (!root || /^0x0+$/i.test(root)) throw new Error(`Root for ${dayStr} not set on-chain yet.`);

      // 4) already claimed?
      const already = await c.isClaimed(BigInt(proof.day), BigInt(proof.index));
      if (already) { log('Already claimed.'); return; }

      // 5) encode + estimate gas + send
      log('Submitting claim transaction...');
      const FN = "claim(uint256,uint256,address,uint256,bytes32[])";
      const args = [
        BigInt(proof.day),
        BigInt(proof.index),
        proof.account,
        BigInt(proof.amountWei),
        proof.proof
      ];
      const data = c.interface.encodeFunctionData(FN, args);

      const gas = await signer.estimateGas({ to: AIRDROP_CONTRACT, data });
      const tx  = await signer.sendTransaction({
        to: AIRDROP_CONTRACT,
        data,
        gasLimit: (gas * 12n) / 10n   // +20% headroom
      });

      log('Tx sent: ' + tx.hash + ' — waiting for confirmation...');
      const rc = await tx.wait();
      log('✅ Claim successful. Tx: ' + rc.transactionHash);

      // 6) refresh button state
      await refreshClaimEligibility();
    }catch(e){
      console.error(e);
      log('❌ Claim failed: ' + (e?.message || e));
      alert('Claim failed: ' + (e?.message || e));
    }
  }

  // ====== Events ======
  $('#btnView').addEventListener('click', viewHistory);
  $('#btnCheck').addEventListener('click', checkBalance);
  $('#btnReq').addEventListener('click', requestPayout);
  $('#btnClaim').addEventListener('click', () => claimOnChain());
  $('#wallet').addEventListener('input', () => { refreshClaimEligibility(); });

  // ====== Boot ======
  if (urlDevice) updateDeviceBadge(walletEl.value.trim(), urlDevice, null);
  if (walletEl.value) viewHistory(); else refreshClaimEligibility();

  // Ping online every 15s
  (async function bootPing(){
    const w = walletEl.value.trim();
    const d = await ensureDeviceId(w);
    if (!d) return;
    await pingOnline();
    if (onlineTimer) clearInterval(onlineTimer);
    onlineTimer = setInterval(pingOnline, 15000);
  })();

})();
</script>
</body>
</html>
