<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ATN Claim</title>
  <style>
  :root{
  --fg:#f1f5f9;       /* chữ sáng */
  --muted:#94a3b8;    /* chữ phụ */
  --border:#334155;   /* viền tối */
  --card:#0f172a;     /* màu nền card */
  --bg:#1e293b;       /* màu nền toàn web */
  --brand:#3b82f6;    /* màu xanh thương hiệu */
}
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--fg);font-size:16px;line-height:1.45}
  .wrap{max-width:1200px;margin:32px auto;padding:0 24px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:18px}
  h1{margin:0 0 14px 0;font-size:24px;display:flex;align-items:center;gap:10px}
  .row{display:flex;gap:10px;flex-wrap:wrap;margin:12px 0}
  input,select,button{padding:12px 14px;border-radius:12px;border:1px solid var(--border);font-size:16px}
  button{background:var(--brand);color:#fff;border:none;cursor:pointer}
  button:disabled{opacity:.5;cursor:not-allowed}
  .muted{color:var(--muted);font-size:13px}
  table{width:100%;border-collapse:collapse;margin-top:14px}
  th,td{border-top:1px solid var(--border);padding:12px 10px;text-align:left;font-variant-numeric:tabular-nums}
  th{background:#f3f4f6}
  .kpi{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:14px;margin-top:14px}
  .kpi .card{padding:16px}
  .kpi .v{font-size:22px;font-weight:700}
  canvas{width:100%;height:360px;border:1px solid var(--border);border-radius:10px;background:#fff}
  .mono{font-family:ui-monospace,Consolas,monospace}
  .readonly{background:#f3f4f6}
  pre{background:#0f172a;color:#e5e7eb;border-radius:12px;padding:12px;overflow:auto}
  .dot{display:inline-block;width:8px;height:8px;border-radius:50%;margin:0 6px}
  .dot.online{background:#16a34a}
  .dot.offline{background:#9ca3af}
  @media(max-width:640px){.wrap{padding:0 16px}.kpi{grid-template-columns:1fr}h1{font-size:20px}}
  </style>
  <!-- Ethers v6 (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1 style="display:flex;align-items:center;gap:10px;margin:0">
  <img src="/claim/images/logo-32.png?v=2"
       alt="ATN Logo"
       style="width:28px;height:28px;border-radius:6px;object-fit:contain">
  ATN Claim
</h1>

      <div class="row">
        <input id="wallet" placeholder="0x... ví BSC" style="flex:1" />
        <select id="days">
         <option value="1" selected>1 ngày</option>
         <option value="7">7 ngày</option>
         <option value="14">14 ngày</option>
         <option value="30">30 ngày</option>
        </select>
        <button id="btnView">Xem</button>
      </div>

      <div class="row">
        <button id="btnCheck">Kiểm tra số dư có thể claim</button>
        <button id="btnReq">Gửi yêu cầu payout (off-chain)</button>
        <button id="btnClaim" disabled title="Sẽ bật khi có Merkle proof/contract">Claim on-chain</button>
      </div>

      <div class="muted">API: <span id="api">https://api.atncrypto.com</span>
        <span id="devBox" class="muted" style="margin-left:8px"></span>
      </div>

      <div class="kpi">
        <div class="card"><div class="muted">Tổng GB</div><div id="kpiGB" class="v">0</div></div>
        <div class="card"><div class="muted">Ước tính ATN</div><div id="kpiATN" class="v">0</div></div>
        <div class="card"><div class="muted">Ngày có dữ liệu</div><div id="kpiDays" class="v">0</div></div>
      </div>

      <div style="margin-top:14px" class="card">
        <canvas id="chart" width="800" height="260"></canvas>
      </div>

      <div class="card" style="margin-top:14px">
        <table>
          <thead><tr><th>Ngày (UTC)</th><th>GB</th><th>ATN (ước tính)</th></tr></thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>

      <div class="card" style="margin-top:14px">
        <div class="muted">Log</div>
        <pre id="log" class="mono"></pre>
      </div>
    </div>
  </div>

<script>
(function(){
  // ====== CONFIG ======
  const API = 'https://api.atncrypto.com'; // đổi nếu backend khác
  const AIRDROP_CONTRACT = '0xc956969fc7dad2B1654Ad98f183A3fDFCE325341'; // contract airdrop của bạn
  document.getElementById('api').textContent = API;

  // ABI tối thiểu
  const AIRDROP_ABI = [
    {"inputs":[{"internalType":"uint256","name":"day","type":"uint256"},{"internalType":"uint256","name":"index","type":"uint256"},{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"amountWei","type":"uint256"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"claim","outputs":[],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[{"internalType":"uint256","name":"day","type":"uint256"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"isClaimed","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
    {"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"roots","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"}
  ];

  // ====== Helpers ======
  const $ = sel => document.querySelector(sel);
  const log = (msg) => { const el = $('#log'); el.textContent = (el.textContent ? el.textContent + "\n" : "") + msg; };
  const clearLog = () => $('#log').textContent = '';
  const isWallet = v => /^0x[a-fA-F0-9]{40}$/.test((v||'').trim());
  async function fetchJSON(url, opts){
    const res = await fetch(url, opts);
    const ct = res.headers.get('content-type') || '';
    const txt = await res.text();
    if (!res.ok) throw new Error(`HTTP ${res.status}: ${txt.slice(0,180)}`);
    if (!ct.includes('application/json')) throw new Error(`Không phải JSON: ${txt.slice(0,180)}`);
    return JSON.parse(txt);
  }
  const fmt = (n, digits=6) => Number(n||0).toLocaleString('en-US',{maximumFractionDigits:digits});
  function z2(n){return String(n).padStart(2,'0');}
  function yesterdayStrUTC(){
    const t=new Date(); t.setUTCDate(t.getUTCDate()-1);
    return `${t.getUTCFullYear()}-${z2(t.getUTCMonth()+1)}-${z2(t.getUTCDate())}`;
  }

  // ====== Params URL ======
  const qs = new URLSearchParams(location.search);
  const urlClaimDay = qs.get('claim_day') || ''; // cho phép ép ngày qua URL
  const walletEl = $('#wallet');
  const urlWallet = qs.get('wallet') || '';
  const urlDevice = qs.get('device') || '';
  const devBox = $('#devBox');
  if (urlWallet) { walletEl.value = urlWallet; walletEl.readOnly = true; walletEl.classList.add('readonly'); }

  // ====== Device helpers ======
  let deviceParam = urlDevice;
  async function ensureDeviceId(wallet){
    if (deviceParam) return deviceParam;
    if (!isWallet(wallet)) return '';
    try{
      const j = await fetchJSON(`${API}/device/binding?wallet=${encodeURIComponent(wallet)}`);
      if (j && j.device_id){
        deviceParam = j.device_id;
        updateDeviceBadge(wallet, deviceParam, false);
      }
    }catch(e){ log('Không lấy được device_id từ server: ' + e.message); }
    return deviceParam;
  }
  function updateDeviceBadge(wallet, device, online){
    const dot = `<span class="dot ${online===true?'online':(online===false?'offline':'')}"></span>`;
    devBox.innerHTML = `Thiết bị: ${device||'-'} ${dot}${online===true?'Online':(online===false?'Offline':'')}`;
  }
  let onlineTimer=null;
  async function pingOnline(){
    const w = walletEl.value.trim();
    if (!isWallet(w)) return;
    const d = await ensureDeviceId(w);
    if (!d) return;
    try{
      const r = await fetchJSON(`${API}/device/online?wallet=${encodeURIComponent(w)}&device=${encodeURIComponent(d)}`);
      updateDeviceBadge(w, d, !!r.online);
    }catch{ updateDeviceBadge(w, d, false); }
  }

  // ====== History ======
  async function fetchHistory(wallet, days){
    return fetchJSON(`${API}/stats/history?wallet=${encodeURIComponent(wallet)}&days=${days}`);
  }
function drawChart(canvas, points){
  // Hiển thị sắc nét trên màn hình retina
  const dpr = window.devicePixelRatio || 1;
  const cssW = canvas.clientWidth || canvas.width;
  const cssH = canvas.clientHeight || canvas.height;
  canvas.width  = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // dùng đơn vị CSS pixel

  const W = cssW, H = cssH;

  // Padding & style
  const L=44, R=14, T=16, B=34;
  const w=W-L-R, h=H-T-B;

  // Nền plot
  ctx.clearRect(0,0,W,H);
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(148,163,184,.15)'; // grid nhạt
  ctx.fillStyle   = 'rgba(15,23,42,.02)';
  ctx.fillRect(L,T,w,h);
  ctx.strokeRect(L,T,w,h);

  if (!points || points.length === 0) return;

  // Scale
  const ys = points.map(p => +p.gb || 0);
  const yMaxRaw = Math.max(...ys, 1);
  const mag = Math.pow(10, Math.floor(Math.log10(yMaxRaw)));
  const yMax = Math.ceil(yMaxRaw / (0.5*mag)) * (0.5*mag);

  const xStep = w / Math.max(1, points.length - 1);
  const xAt = i => L + i * xStep;
  const yAt = v => T + h - (v / yMax) * h;

  // Grid ngang + nhãn Y
  ctx.fillStyle = 'rgba(148,163,184,.7)';
  ctx.font = '13px system-ui, sans-serif';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  const ticks = 4;
  for (let i=0;i<=ticks;i++){
    const yy = T + h - (i/ticks)*h;
    ctx.beginPath(); ctx.moveTo(L,yy); ctx.lineTo(W-R,yy); ctx.stroke();
    const label = (yMax*i/ticks).toLocaleString('en-US', {maximumFractionDigits:2});
    ctx.fillText(label, 6, yy);
  }

  // Line gradient & area fill
  const grad = ctx.createLinearGradient(L, T, L, T+h);
  grad.addColorStop(0, '#3b82f6');
  grad.addColorStop(1, '#2563eb');

  const areaGrad = ctx.createLinearGradient(0, T, 0, T+h);
  areaGrad.addColorStop(0, 'rgba(59,130,246,.32)');
  areaGrad.addColorStop(1, 'rgba(59,130,246,0)');

  // Path cho area
  ctx.beginPath();
  points.forEach((p,i) => {
    const x = xAt(i);
    const y = yAt(+p.gb||0);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.lineTo(L + (points.length-1)*xStep, T+h);
  ctx.lineTo(L, T+h);
  ctx.closePath();
  ctx.fillStyle = areaGrad;
  ctx.fill();

  // Vẽ line
  ctx.beginPath();
  points.forEach((p,i) => {
    const x = xAt(i);
    const y = yAt(+p.gb||0);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.lineWidth = 2.5;
  ctx.lineJoin = 'round';
  ctx.lineCap  = 'round';
  ctx.strokeStyle = grad;
  ctx.stroke();

  // Markers có glow
  points.forEach((p,i)=>{
    const x=xAt(i), y=yAt(+p.gb||0);
    ctx.save();
    ctx.shadowColor = 'rgba(59,130,246,.45)';
    ctx.shadowBlur = 6;
    ctx.fillStyle = '#3b82f6';
    ctx.beginPath(); ctx.arc(x,y,3.2,0,Math.PI*2); ctx.fill();
    ctx.restore();
  });

  // Nhãn X (thưa)
  ctx.fillStyle = 'rgba(148,163,184,.9)';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'alphabetic';
  const step = Math.ceil(points.length/5);
  points.forEach((p,i)=>{
    if (i%step!==0 && i!==points.length-1) return;
    const x=xAt(i);
    ctx.fillText(p.day, x, H-8);
  });

  // trả ra geom cho tooltip
  return {
    xAt, yAt, yMax, rect:{L,R,T,B,w,h,W,H}
  };
}


  // ====== Nút Xem ======
  async function viewHistory(){
    clearLog();
    const wallet = walletEl.value.trim();
    const days = Number($('#days').value);
    if (!isWallet(wallet)) { alert('Nhập ví BSC hợp lệ (0x + 40 hex)'); return; }
    $('#btnView').disabled = true;
    try{
      const data = await fetchHistory(wallet, days);
      const list = Array.isArray(data.daily) ? data.daily : [];
      const totalGB = list.reduce((s,x)=>s+Number(x.gb||0),0);
      const totalATN = list.reduce((s,x)=>s+Number(x.est_atn||0),0);
      $('#kpiGB').textContent = fmt(totalGB,6);
      $('#kpiATN').textContent = fmt(totalATN,6);
      $('#kpiDays').textContent = list.length;
      const tbody = $('#tbody'); tbody.innerHTML='';
      list.forEach(row=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${row.day}</td><td>${fmt(row.gb,6)}</td><td>${fmt(row.est_atn,6)}</td>`;
        tbody.appendChild(tr);
      });
      const points = list.map(r=>({day:r.day, gb:r.gb, ts: Date.parse(r.day+'T00:00:00Z')||0}));

const canvas = $('#chart');
let geom = drawChart(canvas, points);

// Tooltip hover trong canvas
(function attachTooltip(){
  const state = { idx: -1 };
  canvas.onmousemove = (e)=>{
    if (!points.length || !geom) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left);
    const i = Math.round((x - geom.rect.L) / (geom.rect.w / Math.max(1, points.length-1)));
    const idx = Math.min(points.length-1, Math.max(0, i));
    if (idx === state.idx) return;
    state.idx = idx;

    // vẽ lại + overlay tooltip
    geom = drawChart(canvas, points);
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    ctx.setTransform(dpr,0,0,dpr,0,0);

    const px = geom.xAt(idx);
    const py = geom.yAt(+points[idx].gb||0);

    // crosshair
    ctx.strokeStyle = 'rgba(148,163,184,.35)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(px, geom.rect.T); ctx.lineTo(px, geom.rect.T+geom.rect.h); ctx.stroke();

    // popup
    const pad=8;
    const text1 = points[idx].day;
    const text2 = `${Number(points[idx].gb||0).toLocaleString('en-US',{maximumFractionDigits:6})} GB`;
    ctx.font = '12px system-ui, sans-serif';
    const w = Math.max(ctx.measureText(text1).width, ctx.measureText(text2).width) + pad*2;
    const h = 34;
    let bx = px + 10, by = py - h - 10;
    if (bx + w > geom.rect.W - geom.rect.R) bx = px - w - 10;
    if (by < geom.rect.T) by = py + 10;

    ctx.fillStyle = 'rgba(2,6,23,.9)';
    ctx.strokeStyle = 'rgba(59,130,246,.6)';
    ctx.lineWidth = 1;
    if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(bx, by, w, h, 8); ctx.fill(); ctx.stroke(); }
    else { ctx.fillRect(bx, by, w, h); ctx.strokeRect(bx, by, w, h); }

    ctx.fillStyle = '#e2e8f0';
    ctx.textAlign='left'; ctx.textBaseline='top';
    ctx.fillText(text1, bx+pad, by+6);
    ctx.fillStyle = '#93c5fd';
    ctx.fillText(text2, bx+pad, by+18);
  };

  canvas.onmouseleave = ()=>{
    state.idx = -1;
    geom = drawChart(canvas, points);
  };

  window.addEventListener('resize', ()=>{ geom = drawChart(canvas, points); });
})();

log('Tải lịch sử thành công.');

      await refreshClaimEligibility();
    }catch(e){ alert('Lỗi tải dữ liệu: ' + e.message); log('Lỗi history: ' + e.message); console.error(e);
    }finally{ $('#btnView').disabled = false; }
  }

  // ====== Số dư off-chain ======
  async function checkBalance(){
    clearLog();
    const wallet = walletEl.value.trim();
    if (!isWallet(wallet)) { alert('Ví không hợp lệ.'); return; }
    try{
      const r = await fetchJSON(`${API}/payout/balance?wallet=${encodeURIComponent(wallet)}`);
      log(JSON.stringify(r, null, 2));
      if (+r.available_atn >= +r.min) log('✅ Đủ ngưỡng để tạo yêu cầu payout.'); else log('ℹ️ Chưa đủ ngưỡng.');
    }catch(e){ log('Lỗi balance: ' + e.message); }
  }

  // ====== Tạo yêu cầu off-chain ======
  async function requestPayout(){
    clearLog();
    const wallet = walletEl.value.trim();
    if (!isWallet(wallet)) { alert('Ví không hợp lệ.'); return; }
    const device = await ensureDeviceId(wallet);
    if (!device){ alert('Thiếu device_id. Hãy mở trang này từ Extension sau khi đã đăng ký thiết bị.'); log('Thiếu device_id — không thể tạo yêu cầu payout.'); return; }
    try{
      const r = await fetchJSON(`${API}/payout/request`, {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ wallet, device_id: device })
      });
      log(JSON.stringify(r, null, 2));
      if (r.ok) log('✅ Đã ghi nhận yêu cầu payout.');
    }catch(e){ log('Lỗi payout: ' + e.message); }
  }

  // ====== Airdrop APIs ======
  async function getAirdropStatus(wallet, dayStr){
    return fetchJSON(`${API}/airdrop/status?wallet=${encodeURIComponent(wallet)}&day=${encodeURIComponent(dayStr)}`);
  }
  async function getAirdropProof(wallet, dayStr){
    return fetchJSON(`${API}/airdrop/proof?wallet=${encodeURIComponent(wallet)}&day=${encodeURIComponent(dayStr)}`);
  }

  async function refreshClaimEligibility(){
    const btn = $('#btnClaim');
    btn.disabled = true;
    btn.title = 'Sẽ bật khi có Merkle proof/contract';
    const wallet = walletEl.value.trim();
    if (!isWallet(wallet)) return;
    const dayStr = urlClaimDay || yesterdayStrUTC();
    try{
      const st = await getAirdropStatus(wallet, dayStr);
      if (!st.hasEntry){ btn.title = `Ví không có trong airdrop ngày ${dayStr}`; return; }
      if (st.claimed){ btn.title = `Đã claim ngày ${dayStr}`; return; }
      btn.disabled = false;
      btn.title = `Claim ${st.amountWei} wei cho ngày ${dayStr}`;
    }catch(e){
      log('Status lỗi: ' + e.message);
    }
  }

  // ====== MetaMask / BSC signer ======
  async function getSignerBSC(){
    if (!window.ethereum) throw new Error('Chưa phát hiện ví (MetaMask).');
    const provider = new ethers.BrowserProvider(window.ethereum);
    let net = await provider.getNetwork();
    if (net.chainId !== 56n){
      try{
        await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: '0x38' }] });
      }catch (err){
        if (err && (err.code === 4902 || err.code === -32603)){
          await window.ethereum.request({
            method:'wallet_addEthereumChain',
            params:[{
              chainId:'0x38',
              chainName:'Binance Smart Chain',
              nativeCurrency:{ name:'BNB', symbol:'BNB', decimals:18 },
              rpcUrls:['https://bsc-dataseed.binance.org'],
              blockExplorerUrls:['https://bscscan.com']
            }]
          });
        }else{
          throw err;
        }
      }
    }
    return provider.getSigner();
  }

  // ====== Claim on-chain ======
  async function claimOnChain(dayStrOverride){
    clearLog();
    try{
      const wallet = walletEl.value.trim();
      if (!isWallet(wallet)) throw new Error('Ví không hợp lệ.');
      const dayStr = dayStrOverride || urlClaimDay || yesterdayStrUTC();

      // 1) lấy proof từ backend
      const proof = await getAirdropProof(wallet, dayStr);
      // proof: { day:"20250831", index, account, amountWei, proof:[...] }

      // 2) signer + contract (để lấy interface & gọi view)
      const signer = await getSignerBSC();
      const c = new ethers.Contract(AIRDROP_CONTRACT, AIRDROP_ABI, signer);

      // 3) check root đã set chưa
      const root = await c.roots(BigInt(proof.day));
      if (!root || /^0x0+$/i.test(root)) throw new Error(`Ngày ${dayStr} chưa có root on-chain.`);

      // 4) check đã claim chưa
      const already = await c.isClaimed(BigInt(proof.day), BigInt(proof.index));
      if (already) { log('Đã claim trước đó.'); return; }

      // 5) encode calldata + ước lượng gas + gửi tx
      log('Đang gửi giao dịch claim...');
      const FN = "claim(uint256,uint256,address,uint256,bytes32[])";
      const args = [
        BigInt(proof.day),
        BigInt(proof.index),
        proof.account,
        BigInt(proof.amountWei),
        proof.proof
      ];
      const data = c.interface.encodeFunctionData(FN, args);

      const gas = await signer.estimateGas({ to: AIRDROP_CONTRACT, data });
      const tx  = await signer.sendTransaction({
        to: AIRDROP_CONTRACT,
        data,
        gasLimit: (gas * 12n) / 10n   // +20% headroom
      });

      log('Tx gửi: ' + tx.hash + ' — chờ xác nhận...');
      const rc = await tx.wait();
      log('✅ Claim thành công. Tx: ' + rc.transactionHash);

      // 6) cập nhật nút
      await refreshClaimEligibility();
    }catch(e){
      console.error(e);
      log('❌ Claim lỗi: ' + (e?.message || e));
      alert('Claim lỗi: ' + (e?.message || e));
    }
  }

  // ====== Gắn sự kiện ======
  $('#btnView').addEventListener('click', viewHistory);
  $('#btnCheck').addEventListener('click', checkBalance);
  $('#btnReq').addEventListener('click', requestPayout);
  $('#btnClaim').addEventListener('click', () => claimOnChain());
  $('#wallet').addEventListener('input', () => { refreshClaimEligibility(); });

  // ====== Khởi chạy ======
  if (urlDevice) updateDeviceBadge(walletEl.value.trim(), urlDevice, null);
  if (walletEl.value) viewHistory(); else refreshClaimEligibility();

  // Ping online mỗi 15s
  (async function bootPing(){
    const w = walletEl.value.trim();
    const d = await ensureDeviceId(w);
    if (!d) return;
    await pingOnline();
    if (onlineTimer) clearInterval(onlineTimer);
    onlineTimer = setInterval(pingOnline, 15000);
  })();

})();
</script>
</body>
</html>
